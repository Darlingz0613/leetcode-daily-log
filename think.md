# **11.18**
NO.1 
717. 1 比特与 2 比特字符
简单

有两种特殊字符：

    第一种字符可以用一比特 0 表示
    第二种字符可以用两比特（10 或 11）表示

给你一个以 0 结尾的二进制数组 bits ，如果最后一个字符必须是一个一比特字符，则返回 true 。

示例 1:

输入: bits = [1, 0, 0]
输出: true
解释: 唯一的解码方式是将其解析为一个两比特字符和一个一比特字符。
所以最后一个字符是一比特字符。


思路：
1.数一数一的个数,如果1的格式是奇数那就是错  X
先分情况 
    全是1       11 11 就这一种可能 最后一个字符必定不是0
    结尾一个0    11 10 不是
                11 0
    中间有0     10 10 11 10 0        1是奇数 0是偶数
                10 11 10 0 10 11

                10 11 10 0
            如果最后一个是 1 一定错
看题解...
    从前往后看   如果是0的话就无所谓
                如果是1的话下一位必须绑定
                if 0 去掉
                if 1 去掉这一位和下一位
代码：
class Solution:
    def isOneBitCharacter(self, bits: List[int]) -> bool:
        i=0
        n=len(bits)
        while i<n-1:
            if bits[i]==0:
                i+=1
            else:
                i+=2
        return i==n-1

NO.2
Q1. 错误的集合
简单
相关标签
premium lock icon相关企业

集合 s 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 丢失了一个数字 并且 有一个数字重复 。

给定一个数组 nums 代表了集合 S 发生错误后的结果。

请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。

示例 1：

输入：nums = [1,2,2,4]
输出：[2,3]

思路：
    我可以找一个i直接遍历从1到n找出缺失
问了句kimi
*把“原集合 1‥n 的总和”与“当前数组的总和、总个数”各算一次，重复数字由总和差推出，缺失数字由重复数字和总和差联合推出——只用两次累加，无需额外空间。*

 n = len(nums)
        S = sum(nums)                    # 数组总和
        T = n * (n + 1) // 2             # 1..n 正确总和
        seen = set()
        for v in nums:                   # 遍历的是“值”，不是下标
            if v in seen:
                dup = v                  # 抓到重复数
                break
            seen.add(v)
        missing = dup - (S - T)          # 由总和差算出缺失数
        return [dup, missing]